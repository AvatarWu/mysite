import React, { useState, useRef, useEffect } from 'react';
import {
  IonContent,
  IonHeader,
  IonToolbar,
  IonTitle,
  IonButton,
  IonIcon,
  IonInput,
  IonItem,
  IonList,
  IonCard,
  IonCardContent,
  IonCardHeader,
  IonBadge,
  IonSpinner,
  IonText,
  IonFab,
  IonFabButton,
  IonModal,
  IonButtons
} from '@ionic/react';
import {
  send,
  mic,
  micOff,
  close,
  chatbubbleEllipses,
  analytics,
  bulb,
  warning,
  checkmarkCircle
} from 'ionicons/icons';
import AIHealthAssistantService, { ConversationContext } from '../services/AIHealthAssistantService';
import './AIHealthChat.css';

interface Message {
  id: string;
  role: 'user' | 'assistant';
  content: string;
  timestamp: Date;
  type: 'text' | 'insight' | 'recommendation' | 'prediction';
  data?: any;
}

interface AIHealthChatProps {
  userId: string;
  healthData?: any;
  onClose?: () => void;
}

const AIHealthChat: React.FC<AIHealthChatProps> = ({ userId, healthData, onClose }) => {
  const [messages, setMessages] = useState<Message[]>([]);
  const [inputValue, setInputValue] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  const [isRecording, setIsRecording] = useState(false);
  const [showInsights, setShowInsights] = useState(false);
  const [insights, setInsights] = useState<any[]>([]);
  const [recommendations, setRecommendations] = useState<any[]>([]);
  const [predictions, setPredictions] = useState<any[]>([]);
  const [conversationContext, setConversationContext] = useState<ConversationContext | null>(null);
  
  const messagesEndRef = useRef<HTMLDivElement>(null);
  const inputRef = useRef<HTMLIonInputElement>(null);

  useEffect(() => {
    initializeChat();
    scrollToBottom();
  }, []);

  useEffect(() => {
    scrollToBottom();
  }, [messages]);

  /**
   * åˆå§‹åŒ–èŠå¤©
   */
  const initializeChat = async () => {
    try {
      // å‰µå»ºå°è©±ä¸Šä¸‹æ–‡
      const context: ConversationContext = {
        userId,
        sessionId: `session_${Date.now()}`,
        healthData: {
          metrics: healthData?.metrics || {},
          trends: healthData?.trends || {},
          recentRecords: healthData?.recentRecords || []
        },
        conversationHistory: [],
        currentFocus: 'general',
        lastInteraction: new Date()
      };

      setConversationContext(context);

      // æ·»åŠ æ­¡è¿æ¶ˆæ¯
      const welcomeMessage: Message = {
        id: `msg_${Date.now()}`,
        role: 'assistant',
        content: 'æ‚¨å¥½ï¼æˆ‘æ˜¯æ‚¨çš„AIå¥åº·åŠ©æ‰‹ã€‚æˆ‘å¯ä»¥å¹«åŠ©æ‚¨åˆ†æå¥åº·æ•¸æ“šã€æä¾›å€‹æ€§åŒ–å»ºè­°ã€é æ¸¬å¥åº·è¶¨å‹¢ï¼Œä¸¦å›ç­”æ‚¨çš„å¥åº·å•é¡Œã€‚è«‹å‘Šè¨´æˆ‘æ‚¨éœ€è¦ä»€éº¼å¹«åŠ©ï¼Ÿ',
        timestamp: new Date(),
        type: 'text'
      };

      setMessages([welcomeMessage]);

      // å¦‚æœæœ‰å¥åº·æ•¸æ“šï¼Œç”Ÿæˆåˆå§‹æ´å¯Ÿ
      if (healthData?.metrics) {
        await generateInitialInsights();
      }
    } catch (error) {
      console.error('åˆå§‹åŒ–èŠå¤©å¤±æ•—:', error);
    }
  };

  /**
   * ç”Ÿæˆåˆå§‹æ´å¯Ÿ
   */
  const generateInitialInsights = async () => {
    try {
      setIsLoading(true);

      // åˆ†æå¥åº·æ•¸æ“š
      const healthInsights = await AIHealthAssistantService.analyzeHealthData(
        healthData.metrics,
        healthData.trends,
        healthData.recentRecords || []
      );

      // ç”Ÿæˆå¥åº·é æ¸¬
      const healthPredictions = await AIHealthAssistantService.generateHealthPredictions(
        healthData.metrics,
        healthData.trends,
        healthData.recentRecords || []
      );

      // ç”Ÿæˆå€‹æ€§åŒ–å»ºè­°
      const aiRecommendations = await AIHealthAssistantService.generatePersonalizedRecommendations(
        healthInsights,
        healthPredictions,
        { userId }
      );

      setInsights(healthInsights);
      setRecommendations(aiRecommendations);
      setPredictions(healthPredictions);

      // å¦‚æœæœ‰é‡è¦æ´å¯Ÿï¼Œæ·»åŠ åˆ°å°è©±ä¸­
      if (healthInsights.length > 0) {
        const insightMessage: Message = {
          id: `msg_${Date.now()}_insight`,
          role: 'assistant',
          content: `æˆ‘ç™¼ç¾äº†${healthInsights.length}å€‹å¥åº·æ´å¯Ÿï¼ŒåŒ…æ‹¬${healthInsights.slice(0, 2).map(i => i.title).join('ã€')}ç­‰ã€‚é»æ“Šä¸‹æ–¹æŒ‰éˆ•æŸ¥çœ‹è©³ç´°ä¿¡æ¯ã€‚`,
          timestamp: new Date(),
          type: 'insight',
          data: healthInsights
        };

        setMessages(prev => [...prev, insightMessage]);
      }
    } catch (error) {
      console.error('ç”Ÿæˆåˆå§‹æ´å¯Ÿå¤±æ•—:', error);
    } finally {
      setIsLoading(false);
    }
  };

  /**
   * ç™¼é€æ¶ˆæ¯
   */
  const sendMessage = async () => {
    if (!inputValue.trim() || isLoading) return;

    const userMessage: Message = {
      id: `msg_${Date.now()}`,
      role: 'user',
      content: inputValue,
      timestamp: new Date(),
      type: 'text'
    };

    setMessages(prev => [...prev, userMessage]);
    setInputValue('');
    setIsLoading(true);

    try {
      // æ›´æ–°å°è©±ä¸Šä¸‹æ–‡
      if (conversationContext) {
        conversationContext.conversationHistory.push({
          role: 'user',
          content: inputValue,
          timestamp: new Date()
        });
        conversationContext.lastInteraction = new Date();
      }

      // ç”ŸæˆAIå›è¦†
      const aiResponse = await generateAIResponse(inputValue);
      
      const assistantMessage: Message = {
        id: `msg_${Date.now()}_ai`,
        role: 'assistant',
        content: aiResponse.content,
        timestamp: new Date(),
        type: aiResponse.type as 'text' | 'insight' | 'recommendation' | 'prediction',
        data: aiResponse.data
      };

      setMessages(prev => [...prev, assistantMessage]);

      // æ›´æ–°å°è©±ä¸Šä¸‹æ–‡
      if (conversationContext) {
        conversationContext.conversationHistory.push({
          role: 'assistant',
          content: aiResponse.content,
          timestamp: new Date()
        });
      }
    } catch (error) {
      console.error('ç”ŸæˆAIå›è¦†å¤±æ•—:', error);
      
      const errorMessage: Message = {
        id: `msg_${Date.now()}_error`,
        role: 'assistant',
        content: 'æŠ±æ­‰ï¼Œæˆ‘é‡åˆ°äº†ä¸€äº›å•é¡Œã€‚è«‹ç¨å¾Œå†è©¦ï¼Œæˆ–è€…é‡æ–°æè¿°æ‚¨çš„å•é¡Œã€‚',
        timestamp: new Date(),
        type: 'text'
      };

      setMessages(prev => [...prev, errorMessage]);
    } finally {
      setIsLoading(false);
    }
  };

  /**
   * ç”ŸæˆAIå›è¦†
   */
  const generateAIResponse = async (userInput: string): Promise<{ content: string; type: string; data?: any }> => {
    const input = userInput.toLowerCase();

    // å¥åº·æ•¸æ“šæŸ¥è©¢
    if (input.includes('é«”é‡') || input.includes('weight')) {
      if (healthData?.metrics?.weight) {
        const weight = healthData.metrics.weight;
        const bmi = weight.current / Math.pow(1.7, 2);
        return {
          content: `æ‚¨ç›®å‰çš„é«”é‡æ˜¯${weight.current}å…¬æ–¤ï¼ŒBMIç‚º${bmi.toFixed(1)}ã€‚${bmi < 18.5 ? 'é«”é‡åä½ï¼Œå»ºè­°é©ç•¶å¢åŠ ç‡Ÿé¤Šæ”å…¥ã€‚' : bmi > 24.9 ? 'é«”é‡åé«˜ï¼Œå»ºè­°é€²è¡Œé«”é‡ç®¡ç†ã€‚' : 'é«”é‡åœ¨æ­£å¸¸ç¯„åœå…§ï¼Œè«‹ä¿æŒã€‚'}`,
          type: 'text'
        };
      }
    }

    // è¡€å£“æŸ¥è©¢
    if (input.includes('è¡€å£“') || input.includes('blood pressure')) {
      if (healthData?.metrics?.bloodPressure) {
        const bp = healthData.metrics.bloodPressure;
        const status = bp.systolic.current >= 140 || bp.diastolic.current >= 90 ? 'åé«˜' : 
                      bp.systolic.current >= 130 || bp.diastolic.current >= 85 ? 'è‡¨ç•Œ' : 'æ­£å¸¸';
        return {
          content: `æ‚¨ç›®å‰çš„è¡€å£“æ˜¯${bp.systolic.current}/${bp.diastolic.current} mmHgï¼Œå±¬æ–¼${status}ç¯„åœã€‚${status !== 'æ­£å¸¸' ? 'å»ºè­°æ¸›å°‘é¹½åˆ†æ”å…¥ï¼Œä¿æŒè¦å¾‹é‹å‹•ã€‚' : 'è«‹ç¹¼çºŒä¿æŒå¥åº·çš„ç”Ÿæ´»æ–¹å¼ã€‚'}`,
          type: 'text'
        };
      }
    }

    // è¡€ç³–æŸ¥è©¢
    if (input.includes('è¡€ç³–') || input.includes('blood sugar')) {
      if (healthData?.metrics?.bloodSugar) {
        const bs = healthData.metrics.bloodSugar;
        const status = bs.current > 6.1 ? 'åé«˜' : 'æ­£å¸¸';
        return {
          content: `æ‚¨ç›®å‰çš„è¡€ç³–æ˜¯${bs.current} mmol/Lï¼Œå±¬æ–¼${status}ç¯„åœã€‚${status !== 'æ­£å¸¸' ? 'å»ºè­°æ§åˆ¶ç¢³æ°´åŒ–åˆç‰©æ”å…¥ï¼Œå¢åŠ é‹å‹•é‡ã€‚' : 'è«‹ç¹¼çºŒä¿æŒå¥åº·çš„é£²é£Ÿç¿’æ…£ã€‚'}`,
          type: 'text'
        };
      }
    }

    // å»ºè­°æŸ¥è©¢
    if (input.includes('å»ºè­°') || input.includes('å»ºè­°') || input.includes('advice')) {
      if (recommendations.length > 0) {
        const topRecommendations = recommendations.slice(0, 3);
        return {
          content: `æ ¹æ“šæ‚¨çš„å¥åº·ç‹€æ³ï¼Œæˆ‘å»ºè­°æ‚¨ï¼š\n${topRecommendations.map((rec, index) => `${index + 1}. ${rec.title}`).join('\n')}`,
          type: 'recommendation',
          data: topRecommendations
        };
      }
    }

    // é æ¸¬æŸ¥è©¢
    if (input.includes('é æ¸¬') || input.includes('è¶¨å‹¢') || input.includes('prediction')) {
      if (predictions.length > 0) {
        const topPredictions = predictions.slice(0, 2);
        return {
          content: `åŸºæ–¼æ‚¨çš„å¥åº·æ•¸æ“šï¼Œæˆ‘é æ¸¬ï¼š\n${topPredictions.map((pred, index) => `${index + 1}. ${pred.metric}å¯èƒ½åœ¨æœªä¾†1å€‹æœˆå…§${pred.riskLevel === 'high' ? 'éœ€è¦ç‰¹åˆ¥é—œæ³¨' : 'ä¿æŒç©©å®š'}`).join('\n')}`,
          type: 'prediction',
          data: topPredictions
        };
    }
  }

  // ä¸€èˆ¬å¥åº·å»ºè­°
  if (input.includes('é‹å‹•') || input.includes('exercise')) {
    return {
      content: 'å»ºè­°æ‚¨æ¯é€±é€²è¡Œè‡³å°‘150åˆ†é˜çš„ä¸­ç­‰å¼·åº¦æœ‰æ°§é‹å‹•ï¼Œå¦‚å¿«èµ°ã€æ¸¸æ³³æˆ–é¨è‡ªè¡Œè»Šã€‚åŒæ™‚æ¯é€±é€²è¡Œ2-3æ¬¡åŠ›é‡è¨“ç·´ï¼Œå¹«åŠ©å¢å¼·è‚Œè‚‰å’Œéª¨éª¼å¥åº·ã€‚',
      type: 'text'
    };
  }

  if (input.includes('é£²é£Ÿ') || input.includes('diet') || input.includes('ç‡Ÿé¤Š')) {
    return {
      content: 'å»ºè­°æ‚¨éµå¾ªå‡è¡¡é£²é£ŸåŸå‰‡ï¼šå¤šæ”å…¥è”¬èœæ°´æœã€å…¨ç©€ç‰©ã€å„ªè³ªè›‹ç™½è³ªï¼Œæ¸›å°‘é£½å’Œè„‚è‚ªã€åå¼è„‚è‚ªå’Œæ·»åŠ ç³–çš„æ”å…¥ã€‚æ¯å¤©å–è¶³å¤ çš„æ°´ï¼Œæ§åˆ¶ç¸½ç†±é‡æ”å…¥ã€‚',
      type: 'text'
    };
  }

  if (input.includes('ç¡çœ ') || input.includes('sleep')) {
    return {
      content: 'å»ºè­°æ‚¨æ¯æ™šä¿æŒ7-9å°æ™‚çš„å„ªè³ªç¡çœ ã€‚å»ºç«‹è¦å¾‹çš„ç¡çœ æ™‚é–“è¡¨ï¼Œç¡å‰é¿å…ä½¿ç”¨é›»å­è¨­å‚™ï¼Œä¿æŒå®‰éœèˆ’é©çš„ç¡çœ ç’°å¢ƒã€‚',
      type: 'text'
    };
  }

  // é»˜èªå›è¦†
  return {
    content: 'æˆ‘ç†è§£æ‚¨çš„å•é¡Œã€‚ç‚ºäº†çµ¦æ‚¨æ›´æº–ç¢ºçš„å¥åº·å»ºè­°ï¼Œè«‹å‘Šè¨´æˆ‘æ‚¨å…·é«”æƒ³äº†è§£å“ªå€‹æ–¹é¢çš„å¥åº·ä¿¡æ¯ï¼Œæ¯”å¦‚é«”é‡ã€è¡€å£“ã€è¡€ç³–ã€é‹å‹•ã€é£²é£Ÿç­‰ã€‚',
    type: 'text'
  };
};

/**
 * æ»¾å‹•åˆ°åº•éƒ¨
 */
const scrollToBottom = () => {
  messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
};

/**
 * è™•ç†éµç›¤äº‹ä»¶
 */
const handleKeyPress = (event: React.KeyboardEvent) => {
  if (event.key === 'Enter' && !event.shiftKey) {
    event.preventDefault();
    sendMessage();
  }
};

/**
 * é–‹å§‹èªéŸ³è¼¸å…¥
 */
const startVoiceInput = () => {
  setIsRecording(true);
  // é€™è£¡å¯ä»¥é›†æˆèªéŸ³è­˜åˆ¥åŠŸèƒ½
  setTimeout(() => {
    setIsRecording(false);
    setInputValue('èªéŸ³è¼¸å…¥åŠŸèƒ½é–‹ç™¼ä¸­...');
  }, 2000);
};

/**
 * æ¸²æŸ“æ¶ˆæ¯
 */
const renderMessage = (message: Message) => {
  const isUser = message.role === 'user';
  
  return (
    <div key={message.id} className={`message ${isUser ? 'user' : 'assistant'}`}>
      <div className="message-avatar">
        {isUser ? (
          <div className="user-avatar">
            <img src="/assets/user-avatar.png" alt="ç”¨æˆ¶" />
          </div>
        ) : (
          <div className="ai-avatar">
            <span className="ai-icon">ğŸ¤–</span>
          </div>
        )}
      </div>
      
      <div className="message-content">
        <div className="message-bubble">
          <IonText>{message.content}</IonText>
          
          {message.type === 'insight' && message.data && (
            <div className="message-insights">
              <IonButton 
                size="small" 
                fill="clear"
                onClick={() => setShowInsights(true)}
              >
                <IonIcon icon={analytics} slot="start" />
                æŸ¥çœ‹æ´å¯Ÿ
              </IonButton>
            </div>
          )}
          
          {message.type === 'recommendation' && message.data && (
            <div className="message-recommendations">
              <IonButton 
                size="small" 
                fill="clear"
                onClick={() => setShowInsights(true)}
              >
                <IonIcon icon={bulb} slot="start" />
                æŸ¥çœ‹å»ºè­°
              </IonButton>
            </div>
          )}
        </div>
        
        <div className="message-time">
          {message.timestamp.toLocaleTimeString('zh-TW', { 
            hour: '2-digit', 
            minute: '2-digit' 
          })}
        </div>
      </div>
    </div>
  );
};

return (
  <>
    <IonContent className="ai-health-chat">
      <IonHeader>
        <IonToolbar>
          <IonTitle>AIå¥åº·åŠ©æ‰‹</IonTitle>
          <IonButtons slot="end">
            <IonButton onClick={onClose}>
              <IonIcon icon={close} />
            </IonButton>
          </IonButtons>
        </IonToolbar>
      </IonHeader>

      <div className="chat-container">
        <div className="messages-container">
          {messages.map(renderMessage)}
          
          {isLoading && (
            <div className="message assistant">
              <div className="message-avatar">
                <div className="ai-avatar">
                  <IonIcon icon={chatbubbleEllipses} />
                </div>
              </div>
              <div className="message-content">
                <div className="message-bubble">
                  <IonSpinner name="dots" />
                  <IonText>æ­£åœ¨æ€è€ƒ...</IonText>
                </div>
              </div>
            </div>
          )}
          
          <div ref={messagesEndRef} />
        </div>

        <div className="input-container">
          <IonItem className="input-item">
            <IonInput
              ref={inputRef}
              value={inputValue}
              onIonInput={(e) => setInputValue(e.detail.value || '')}
              onKeyPress={handleKeyPress}
              placeholder="è¼¸å…¥æ‚¨çš„å¥åº·å•é¡Œ..."
              className="chat-input"
            />
            <IonButton
              slot="end"
              fill="clear"
              onClick={startVoiceInput}
              disabled={isRecording}
            >
              <IonIcon icon={isRecording ? micOff : mic} />
            </IonButton>
            <IonButton
              slot="end"
              fill="clear"
              onClick={sendMessage}
              disabled={!inputValue.trim() || isLoading}
            >
              <IonIcon icon={send} />
            </IonButton>
          </IonItem>
        </div>
      </div>

      <IonFab vertical="bottom" horizontal="end" slot="fixed">
        <IonFabButton 
          size="small"
          onClick={() => setShowInsights(true)}
          color="primary"
        >
          <IonIcon icon={analytics} />
        </IonFabButton>
      </IonFab>
    </IonContent>

    <IonModal isOpen={showInsights} onDidDismiss={() => setShowInsights(false)}>
      <IonHeader>
        <IonToolbar>
          <IonTitle>å¥åº·æ´å¯Ÿèˆ‡å»ºè­°</IonTitle>
          <IonButtons slot="end">
            <IonButton onClick={() => setShowInsights(false)}>
              <IonIcon icon={close} />
            </IonButton>
          </IonButtons>
        </IonToolbar>
      </IonHeader>

      <IonContent>
        {insights.length > 0 && (
          <IonCard>
            <IonCardHeader>
              <IonTitle>
                <IonIcon icon={analytics} />
                å¥åº·æ´å¯Ÿ
              </IonTitle>
            </IonCardHeader>
            <IonCardContent>
              <IonList>
                {insights.map((insight) => (
                  <IonItem key={insight.id}>
                    <div className="insight-item">
                      <div className="insight-header">
                        <IonText className="insight-title">{insight.title}</IonText>
                        <IonBadge 
                          color={insight.severity === 'critical' ? 'danger' : 
                                 insight.severity === 'high' ? 'warning' : 
                                 insight.severity === 'medium' ? 'primary' : 'success'}
                        >
                          {insight.severity}
                        </IonBadge>
                      </div>
                      <IonText className="insight-description">{insight.description}</IonText>
                      {insight.actionItems && (
                        <div className="insight-actions">
                          {insight.actionItems.map((action, index) => (
                            <div key={index} className="action-item">
                              <IonIcon icon={checkmarkCircle} />
                              <IonText>{action}</IonText>
                            </div>
                          ))}
                        </div>
                      )}
                    </div>
                  </IonItem>
                ))}
              </IonList>
            </IonCardContent>
          </IonCard>
        )}

        {recommendations.length > 0 && (
          <IonCard>
            <IonCardHeader>
              <IonTitle>
                <IonIcon icon={bulb} />
                AIå»ºè­°
              </IonTitle>
            </IonCardHeader>
            <IonCardContent>
              <IonList>
                {recommendations.map((rec) => (
                  <IonItem key={rec.id}>
                    <div className="recommendation-item">
                      <div className="recommendation-header">
                        <IonText className="recommendation-title">{rec.title}</IonText>
                        <IonBadge 
                          color={rec.priority === 'urgent' ? 'danger' : 
                                 rec.priority === 'high' ? 'warning' : 
                                 rec.priority === 'medium' ? 'primary' : 'success'}
                        >
                          {rec.priority}
                        </IonBadge>
                      </div>
                      <IonText className="recommendation-description">{rec.description}</IonText>
                      <div className="recommendation-meta">
                        <IonBadge color="medium">é›£åº¦: {rec.difficulty}</IonBadge>
                        <IonBadge color="medium">å½±éŸ¿: {rec.estimatedImpact}</IonBadge>
                        <IonBadge color="medium">æ™‚é–“: {rec.timeToImplement}</IonBadge>
                      </div>
                    </div>
                  </IonItem>
                ))}
              </IonList>
            </IonCardContent>
          </IonCard>
        )}

        {predictions.length > 0 && (
          <IonCard>
            <IonCardHeader>
              <IonTitle>
                <IonIcon icon={warning} />
                å¥åº·é æ¸¬
              </IonTitle>
            </IonCardHeader>
            <IonCardContent>
              <IonList>
                {predictions.map((pred) => (
                  <IonItem key={pred.id}>
                    <div className="prediction-item">
                      <div className="prediction-header">
                        <IonText className="prediction-title">{pred.metric}é æ¸¬</IonText>
                        <IonBadge 
                          color={pred.riskLevel === 'high' ? 'danger' : 
                                 pred.riskLevel === 'medium' ? 'warning' : 'success'}
                        >
                          {pred.riskLevel}
                        </IonBadge>
                      </div>
                      <IonText className="prediction-description">
                        ç•¶å‰å€¼: {pred.currentValue} â†’ é æ¸¬å€¼: {pred.predictedValue}
                      </IonText>
                      <div className="prediction-factors">
                        <IonText className="factors-title">å½±éŸ¿å› ç´ :</IonText>
                        {pred.factors.map((factor, index) => (
                          <IonBadge key={index} color="medium">{factor}</IonBadge>
                        ))}
                      </div>
                    </div>
                  </IonItem>
                ))}
              </IonList>
            </IonCardContent>
          </IonCard>
        )}
      </IonContent>
    </IonModal>
  </>
);
};

export default AIHealthChat;
